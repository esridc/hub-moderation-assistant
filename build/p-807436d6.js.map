{"version":3,"names":["labelClickEvent","labelConnectedEvent","labelDisconnectedEvent","labelTagName","labelToLabelables","WeakMap","onLabelClickMap","onLabelConnectedMap","onLabelDisconnectedMap","unlabeledComponents","Set","findLabelForComponent","componentEl","id","forLabel","queryElementRoots","selector","parentLabel","closestElementCrossShadowBoundary","hasAncestorCustomElements","label","traversedElements","customElementAncestorCheckEventType","listener","event","stopImmediatePropagation","composedPath","slice","indexOf","addEventListener","once","dispatchEvent","CustomEvent","composed","bubbles","removeEventListener","ancestorCustomElements","filter","el","tagName","includes","length","connectLabel","component","labelEl","has","boundOnLabelDisconnected","onLabelDisconnected","bind","labelables","get","push","set","sort","sortByDOMOrder","onLabelClick","delete","document","disconnectLabel","labelable","a","b","isBefore","getLabelText","textContent","trim","labelClickTarget","detail","sourceEvent","target","this","clickedLabelable","find","labelableChildClicked","firstLabelable","disabled","onLabelConnected","add","boundOnLabelConnected","async","associateExplicitLabelToUnlabeledComponent","componentOnReady","alreadyLabeled","forComponentEl","ownerDocument","getElementById","for","requestAnimationFrame"],"sources":["./node_modules/@esri/calcite-components/dist/collection/utils/label.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.\n * v2.11.1\n */\nimport { closestElementCrossShadowBoundary, isBefore, queryElementRoots } from \"./dom\";\nimport { componentOnReady } from \"./component\";\n/**\n * Exported for testing purposes only\n *\n * @internal\n */\nexport const labelClickEvent = \"calciteInternalLabelClick\";\nexport const labelConnectedEvent = \"calciteInternalLabelConnected\";\nexport const labelDisconnectedEvent = \"calciteInternalLabelDisconnected\";\nconst labelTagName = \"calcite-label\";\nconst labelToLabelables = new WeakMap();\nconst onLabelClickMap = new WeakMap();\nconst onLabelConnectedMap = new WeakMap();\nconst onLabelDisconnectedMap = new WeakMap();\nconst unlabeledComponents = new Set();\nconst findLabelForComponent = (componentEl) => {\n    const { id } = componentEl;\n    const forLabel = id && queryElementRoots(componentEl, { selector: `${labelTagName}[for=\"${id}\"]` });\n    if (forLabel) {\n        return forLabel;\n    }\n    const parentLabel = closestElementCrossShadowBoundary(componentEl, labelTagName);\n    if (!parentLabel ||\n        // labelable components within other custom elements are not considered labelable\n        hasAncestorCustomElements(parentLabel, componentEl)) {\n        return null;\n    }\n    return parentLabel;\n};\nfunction hasAncestorCustomElements(label, componentEl) {\n    let traversedElements;\n    const customElementAncestorCheckEventType = \"custom-element-ancestor-check\";\n    const listener = (event) => {\n        event.stopImmediatePropagation();\n        const composedPath = event.composedPath();\n        traversedElements = composedPath.slice(composedPath.indexOf(componentEl), composedPath.indexOf(label));\n    };\n    label.addEventListener(customElementAncestorCheckEventType, listener, { once: true });\n    componentEl.dispatchEvent(new CustomEvent(customElementAncestorCheckEventType, { composed: true, bubbles: true }));\n    label.removeEventListener(customElementAncestorCheckEventType, listener);\n    const ancestorCustomElements = traversedElements\n        .filter((el) => el !== componentEl && el !== label)\n        .filter((el) => el.tagName?.includes(\"-\"));\n    return ancestorCustomElements.length > 0;\n}\n/**\n * Helper to set up label interactions on connectedCallback.\n *\n * @param component\n */\nexport function connectLabel(component) {\n    if (!component) {\n        return;\n    }\n    const labelEl = findLabelForComponent(component.el);\n    if ((onLabelClickMap.has(labelEl) && labelEl === component.labelEl) ||\n        (!labelEl && unlabeledComponents.has(component))) {\n        return;\n    }\n    const boundOnLabelDisconnected = onLabelDisconnected.bind(component);\n    if (labelEl) {\n        component.labelEl = labelEl;\n        const labelables = labelToLabelables.get(labelEl) || [];\n        labelables.push(component);\n        labelToLabelables.set(labelEl, labelables.sort(sortByDOMOrder));\n        if (!onLabelClickMap.has(component.labelEl)) {\n            onLabelClickMap.set(component.labelEl, onLabelClick);\n            component.labelEl.addEventListener(labelClickEvent, onLabelClick);\n        }\n        unlabeledComponents.delete(component);\n        document.removeEventListener(labelConnectedEvent, onLabelConnectedMap.get(component));\n        onLabelDisconnectedMap.set(component, boundOnLabelDisconnected);\n        document.addEventListener(labelDisconnectedEvent, boundOnLabelDisconnected);\n    }\n    else if (!unlabeledComponents.has(component)) {\n        boundOnLabelDisconnected();\n        document.removeEventListener(labelDisconnectedEvent, onLabelDisconnectedMap.get(component));\n    }\n}\n/**\n * Helper to tear down label interactions on disconnectedCallback on labelable components.\n *\n * @param component\n */\nexport function disconnectLabel(component) {\n    if (!component) {\n        return;\n    }\n    unlabeledComponents.delete(component);\n    document.removeEventListener(labelConnectedEvent, onLabelConnectedMap.get(component));\n    document.removeEventListener(labelDisconnectedEvent, onLabelDisconnectedMap.get(component));\n    onLabelConnectedMap.delete(component);\n    onLabelDisconnectedMap.delete(component);\n    if (!component.labelEl) {\n        return;\n    }\n    const labelables = labelToLabelables.get(component.labelEl);\n    if (labelables.length === 1) {\n        component.labelEl.removeEventListener(labelClickEvent, onLabelClickMap.get(component.labelEl));\n        onLabelClickMap.delete(component.labelEl);\n    }\n    labelToLabelables.set(component.labelEl, labelables.filter((labelable) => labelable !== component).sort(sortByDOMOrder));\n    component.labelEl = null;\n}\nfunction sortByDOMOrder(a, b) {\n    return isBefore(a.el, b.el) ? -1 : 1;\n}\n/**\n * Helper to get the label text from a component.\n *\n * @param component\n */\nexport function getLabelText(component) {\n    return component.label || component.labelEl?.textContent?.trim() || \"\";\n}\nfunction onLabelClick(event) {\n    const labelClickTarget = event.detail.sourceEvent.target;\n    const labelables = labelToLabelables.get(this);\n    const clickedLabelable = labelables.find((labelable) => labelable.el === labelClickTarget);\n    const labelableChildClicked = labelables.includes(clickedLabelable);\n    if (labelableChildClicked) {\n        // no need to forward click as labelable will receive focus\n        return;\n    }\n    const firstLabelable = labelables[0];\n    if (firstLabelable.disabled) {\n        return;\n    }\n    firstLabelable.onLabelClick(event);\n}\nfunction onLabelConnected() {\n    if (unlabeledComponents.has(this)) {\n        connectLabel(this);\n    }\n}\nfunction onLabelDisconnected() {\n    unlabeledComponents.add(this);\n    const boundOnLabelConnected = onLabelConnectedMap.get(this) || onLabelConnected.bind(this);\n    onLabelConnectedMap.set(this, boundOnLabelConnected);\n    document.addEventListener(labelConnectedEvent, boundOnLabelConnected);\n}\n/**\n * Helper to associate an explicit label (i.e., using `for`) with a labelable component that does not have an associated label.\n *\n * @param label - the label element\n */\nexport async function associateExplicitLabelToUnlabeledComponent(label) {\n    await componentOnReady(label);\n    const alreadyLabeled = labelToLabelables.has(label);\n    if (alreadyLabeled) {\n        return;\n    }\n    const forComponentEl = label.ownerDocument?.getElementById(label.for);\n    if (!forComponentEl) {\n        return;\n    }\n    requestAnimationFrame(() => {\n        for (const labelable of unlabeledComponents) {\n            if (labelable.el === forComponentEl) {\n                connectLabel(labelable);\n                break;\n            }\n        }\n    });\n}\n//# sourceMappingURL=label.js.map\n"],"mappings":"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"}