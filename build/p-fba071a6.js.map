{"version":3,"names":["inRange","date","min","max","time","getTime","afterMin","Date","beforeMax","dateFromRange","beforeMin","afterMax","dateFromISO","iso8601","isEndDate","d","split","map","parseFloat","setFullYear","isNaN","Error","setEndOfDay","dateFromLocalizedString","value","localeData","separator","parts","parseDateString","day","month","year","parseCalendarYear","validDay","validMonth","validDate","validLength","filter","c","length","validYear","toString","processCalendarYear","formatCalendarYear","mode","BUDDHIST_CALENDAR_YEAR_OFFSET","yearOffset","datePartsFromLocalizedString","string","unitOrder","order","getOrder","values","part","numberStringFormatter","delocalize","indexOf","dateToISO","String","getMonth","padStart","getDate","getFullYear","datePartsFromISO","isoDate","dateParts","sameDate","d1","d2","prevMonth","nextDate","setMonth","nextMonth","parseInt","signifiers","toLowerCase","sort","a","b","getDaysDiff","date1","date2","ts1","ts2","setHours"],"sources":["./node_modules/@esri/calcite-components/dist/collection/utils/date.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.\n * v2.11.1\n */\nimport { numberStringFormatter } from \"./locale\";\n/**\n * Check if date is within a min and max\n *\n * @param date\n * @param min\n * @param max\n */\nexport function inRange(date, min, max) {\n    if (!date) {\n        return;\n    }\n    const time = date.getTime();\n    const afterMin = !(min instanceof Date) || time >= min.getTime();\n    const beforeMax = !(max instanceof Date) || time <= max.getTime();\n    return afterMin && beforeMax;\n}\n/**\n * Ensures date is within range,\n * returns min or max if out of bounds\n *\n * @param date\n * @param min\n * @param max\n */\nexport function dateFromRange(date, min, max) {\n    if (!(date instanceof Date)) {\n        return null;\n    }\n    const time = date.getTime();\n    const beforeMin = min instanceof Date && time < min.getTime();\n    const afterMax = max instanceof Date && time > max.getTime();\n    if (beforeMin) {\n        return min;\n    }\n    if (afterMax) {\n        return max;\n    }\n    return date;\n}\n/**\n * Parse an iso8601 string (YYYY-mm-dd) into a valid date.\n * TODO: handle time when time of day UI is added\n *\n * @param iso8601\n * @param isEndDate\n */\nexport function dateFromISO(iso8601, isEndDate = false) {\n    if (iso8601 instanceof Date) {\n        return iso8601;\n    }\n    if (!iso8601 || typeof iso8601 !== \"string\") {\n        return null;\n    }\n    const d = iso8601.split(/[: T-]/).map(parseFloat);\n    const date = new Date(d[0], (d[1] || 1) - 1, d[2] || 1);\n    date.setFullYear(d[0]);\n    if (isNaN(date.getTime())) {\n        throw new Error(`Invalid ISO 8601 date: \"${iso8601}\"`);\n    }\n    if (isEndDate) {\n        return setEndOfDay(date);\n    }\n    return date;\n}\n/**\n * Parse a localized date string into a valid Date.\n * return false if date is invalid, or out of range\n *\n * @param value\n * @param localeData\n */\nexport function dateFromLocalizedString(value, localeData) {\n    if (!localeData) {\n        return null;\n    }\n    const { separator } = localeData;\n    const parts = parseDateString(value, localeData);\n    const { day, month } = parts;\n    const year = parseCalendarYear(parts.year, localeData);\n    const date = new Date(year, month, day);\n    date.setFullYear(year);\n    const validDay = day > 0;\n    const validMonth = month > -1;\n    const validDate = !isNaN(date.getTime());\n    const validLength = value.split(separator).filter((c) => c).length > 2;\n    const validYear = year.toString().length > 0;\n    if (validDay && validMonth && validDate && validLength && validYear) {\n        return date;\n    }\n    return null;\n}\nexport function parseCalendarYear(year, localeData) {\n    return processCalendarYear(year, localeData, \"read\");\n}\nexport function formatCalendarYear(year, localeData) {\n    return processCalendarYear(year, localeData, \"write\");\n}\nfunction processCalendarYear(year, localeData, mode) {\n    if (localeData[\"default-calendar\"] !== \"buddhist\") {\n        return year;\n    }\n    const BUDDHIST_CALENDAR_YEAR_OFFSET = 543;\n    const yearOffset = BUDDHIST_CALENDAR_YEAR_OFFSET * (mode === \"read\" ? -1 : 1);\n    return year + yearOffset;\n}\n/**\n * Retrieve day, month, and year strings from a localized string\n *\n * @param string\n * @param localeData\n */\nexport function datePartsFromLocalizedString(string, localeData) {\n    const { separator, unitOrder } = localeData;\n    const order = getOrder(unitOrder);\n    const values = string.split(separator).map((part) => numberStringFormatter.delocalize(part));\n    const day = values[order.indexOf(\"d\")];\n    const month = values[order.indexOf(\"m\")];\n    const year = values[order.indexOf(\"y\")];\n    return { day, month, year };\n}\n/**\n * Return the date portion in local time of a Date object in ISO 8601 format (YYYY-MM-DD)\n *\n * @param date\n */\nexport function dateToISO(date) {\n    if (date instanceof Date) {\n        const month = String(date.getMonth() + 1).padStart(2, \"0\");\n        const day = String(date.getDate()).padStart(2, \"0\");\n        const year = String(date.getFullYear()).padStart(4, \"0\");\n        return `${year}-${month}-${day}`;\n    }\n    return \"\";\n}\n/**\n * Retrieve day, month, and year strings from a ISO string (YYYY-mm-dd)\n *\n * @param string\n * @param isoDate\n */\nexport function datePartsFromISO(isoDate) {\n    const dateParts = isoDate.split(\"-\");\n    return { day: dateParts[2], month: dateParts[1], year: dateParts[0] };\n}\n/**\n * Check if two dates are the same day, month, year\n *\n * @param d1\n * @param d2\n */\nexport function sameDate(d1, d2) {\n    return (d1 instanceof Date &&\n        d2 instanceof Date &&\n        d1.getDate() === d2.getDate() &&\n        d1.getMonth() === d2.getMonth() &&\n        d1.getFullYear() === d2.getFullYear());\n}\n/**\n * Get a date one month in the past\n *\n * @param date\n */\nexport function prevMonth(date) {\n    const month = date.getMonth();\n    const nextDate = new Date(date);\n    nextDate.setMonth(month - 1);\n    // date doesn't exist in new month, use last day\n    if (month === nextDate.getMonth()) {\n        return new Date(date.getFullYear(), month, 0);\n    }\n    return nextDate;\n}\n/**\n * Get a date one month in the future\n *\n * @param date\n */\nexport function nextMonth(date) {\n    const month = date.getMonth();\n    const nextDate = new Date(date);\n    nextDate.setMonth(month + 1);\n    // date doesn't exist in new month, use last day\n    if ((month + 2) % 7 === nextDate.getMonth() % 7) {\n        return new Date(date.getFullYear(), month + 2, 0);\n    }\n    return nextDate;\n}\n/**\n * Parse numeric units for day, month, and year from a localized string\n * month starts at 0 (can pass to date constructor)\n * can return values as number or string\n *\n * @param string\n * @param localeData\n */\nexport function parseDateString(string, localeData) {\n    const { day, month, year } = datePartsFromLocalizedString(string, localeData);\n    return {\n        day: parseInt(day),\n        month: parseInt(month) - 1, // this subtracts by 1 because the month in the Date constructor is zero-based https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getMonth\n        year: parseInt(year),\n    };\n}\n/**\n * Based on the unitOrder string, find order of month, day, and year for locale\n *\n * @param unitOrder\n */\nexport function getOrder(unitOrder) {\n    const signifiers = [\"d\", \"m\", \"y\"];\n    const order = unitOrder.toLowerCase();\n    return signifiers.sort((a, b) => order.indexOf(a) - order.indexOf(b));\n}\n/**\n * Get number of days between two dates\n *\n * @param date1\n * @param date2\n */\nexport function getDaysDiff(date1, date2) {\n    const ts1 = date1.getTime();\n    const ts2 = date2.getTime();\n    return (ts1 - ts2) / (1000 * 3600 * 24);\n}\n/**\n * Set time of the day to the end.\n *\n * @param {Date} date Date.\n * @returns {Date} Date with time set to end of day .\n */\nexport function setEndOfDay(date) {\n    date.setHours(23, 59, 59, 999);\n    return date;\n}\n//# sourceMappingURL=date.js.map\n"],"mappings":";;;;;GAaO,SAASA,EAAQC,EAAMC,EAAKC,GAC/B,IAAKF,EAAM,CACP,MACR,CACI,MAAMG,EAAOH,EAAKI,UAClB,MAAMC,IAAaJ,aAAeK,OAASH,GAAQF,EAAIG,UACvD,MAAMG,IAAcL,aAAeI,OAASH,GAAQD,EAAIE,UACxD,OAAOC,GAAYE,CACvB,CASO,SAASC,EAAcR,EAAMC,EAAKC,GACrC,KAAMF,aAAgBM,MAAO,CACzB,OAAO,IACf,CACI,MAAMH,EAAOH,EAAKI,UAClB,MAAMK,EAAYR,aAAeK,MAAQH,EAAOF,EAAIG,UACpD,MAAMM,EAAWR,aAAeI,MAAQH,EAAOD,EAAIE,UACnD,GAAIK,EAAW,CACX,OAAOR,CACf,CACI,GAAIS,EAAU,CACV,OAAOR,CACf,CACI,OAAOF,CACX,CAQO,SAASW,EAAYC,EAASC,EAAY,OAC7C,GAAID,aAAmBN,KAAM,CACzB,OAAOM,CACf,CACI,IAAKA,UAAkBA,IAAY,SAAU,CACzC,OAAO,IACf,CACI,MAAME,EAAIF,EAAQG,MAAM,UAAUC,IAAIC,YACtC,MAAMjB,EAAO,IAAIM,KAAKQ,EAAE,IAAKA,EAAE,IAAM,GAAK,EAAGA,EAAE,IAAM,GACrDd,EAAKkB,YAAYJ,EAAE,IACnB,GAAIK,MAAMnB,EAAKI,WAAY,CACvB,MAAM,IAAIgB,MAAM,2BAA2BR,KACnD,CACI,GAAIC,EAAW,CACX,OAAOQ,EAAYrB,EAC3B,CACI,OAAOA,CACX,CAQO,SAASsB,EAAwBC,EAAOC,GAC3C,IAAKA,EAAY,CACb,OAAO,IACf,CACI,MAAMC,UAAEA,GAAcD,EACtB,MAAME,EAAQC,EAAgBJ,EAAOC,GACrC,MAAMI,IAAEA,EAAGC,MAAEA,GAAUH,EACvB,MAAMI,EAAOC,EAAkBL,EAAMI,KAAMN,GAC3C,MAAMxB,EAAO,IAAIM,KAAKwB,EAAMD,EAAOD,GACnC5B,EAAKkB,YAAYY,GACjB,MAAME,EAAWJ,EAAM,EACvB,MAAMK,EAAaJ,GAAS,EAC5B,MAAMK,GAAaf,MAAMnB,EAAKI,WAC9B,MAAM+B,EAAcZ,EAAMR,MAAMU,GAAWW,QAAQC,GAAMA,IAAGC,OAAS,EACrE,MAAMC,EAAYT,EAAKU,WAAWF,OAAS,EAC3C,GAAIN,GAAYC,GAAcC,GAAaC,GAAeI,EAAW,CACjE,OAAOvC,CACf,CACI,OAAO,IACX,CACO,SAAS+B,EAAkBD,EAAMN,GACpC,OAAOiB,EAAoBX,EAAMN,EAAY,OACjD,CACO,SAASkB,EAAmBZ,EAAMN,GACrC,OAAOiB,EAAoBX,EAAMN,EAAY,QACjD,CACA,SAASiB,EAAoBX,EAAMN,EAAYmB,GAC3C,GAAInB,EAAW,sBAAwB,WAAY,CAC/C,OAAOM,CACf,CACI,MAAMc,EAAgC,IACtC,MAAMC,EAAaD,GAAiCD,IAAS,QAAU,EAAI,GAC3E,OAAOb,EAAOe,CAClB,CAOO,SAASC,EAA6BC,EAAQvB,GACjD,MAAMC,UAAEA,EAASuB,UAAEA,GAAcxB,EACjC,MAAMyB,EAAQC,EAASF,GACvB,MAAMG,EAASJ,EAAOhC,MAAMU,GAAWT,KAAKoC,GAASC,EAAsBC,WAAWF,KACtF,MAAMxB,EAAMuB,EAAOF,EAAMM,QAAQ,MACjC,MAAM1B,EAAQsB,EAAOF,EAAMM,QAAQ,MACnC,MAAMzB,EAAOqB,EAAOF,EAAMM,QAAQ,MAClC,MAAO,CAAE3B,MAAKC,QAAOC,OACzB,CAMO,SAAS0B,EAAUxD,GACtB,GAAIA,aAAgBM,KAAM,CACtB,MAAMuB,EAAQ4B,OAAOzD,EAAK0D,WAAa,GAAGC,SAAS,EAAG,KACtD,MAAM/B,EAAM6B,OAAOzD,EAAK4D,WAAWD,SAAS,EAAG,KAC/C,MAAM7B,EAAO2B,OAAOzD,EAAK6D,eAAeF,SAAS,EAAG,KACpD,MAAO,GAAG7B,KAAQD,KAASD,GACnC,CACI,MAAO,EACX,CAOO,SAASkC,EAAiBC,GAC7B,MAAMC,EAAYD,EAAQhD,MAAM,KAChC,MAAO,CAAEa,IAAKoC,EAAU,GAAInC,MAAOmC,EAAU,GAAIlC,KAAMkC,EAAU,GACrE,CAOO,SAASC,EAASC,EAAIC,GACzB,OAAQD,aAAc5D,MAClB6D,aAAc7D,MACd4D,EAAGN,YAAcO,EAAGP,WACpBM,EAAGR,aAAeS,EAAGT,YACrBQ,EAAGL,gBAAkBM,EAAGN,aAChC,CAMO,SAASO,EAAUpE,GACtB,MAAM6B,EAAQ7B,EAAK0D,WACnB,MAAMW,EAAW,IAAI/D,KAAKN,GAC1BqE,EAASC,SAASzC,EAAQ,GAE1B,GAAIA,IAAUwC,EAASX,WAAY,CAC/B,OAAO,IAAIpD,KAAKN,EAAK6D,cAAehC,EAAO,EACnD,CACI,OAAOwC,CACX,CAMO,SAASE,EAAUvE,GACtB,MAAM6B,EAAQ7B,EAAK0D,WACnB,MAAMW,EAAW,IAAI/D,KAAKN,GAC1BqE,EAASC,SAASzC,EAAQ,GAE1B,IAAKA,EAAQ,GAAK,IAAMwC,EAASX,WAAa,EAAG,CAC7C,OAAO,IAAIpD,KAAKN,EAAK6D,cAAehC,EAAQ,EAAG,EACvD,CACI,OAAOwC,CACX,CASO,SAAS1C,EAAgBoB,EAAQvB,GACpC,MAAMI,IAAEA,EAAGC,MAAEA,EAAKC,KAAEA,GAASgB,EAA6BC,EAAQvB,GAClE,MAAO,CACHI,IAAK4C,SAAS5C,GACdC,MAAO2C,SAAS3C,GAAS,EACzBC,KAAM0C,SAAS1C,GAEvB,CAMO,SAASoB,EAASF,GACrB,MAAMyB,EAAa,CAAC,IAAK,IAAK,KAC9B,MAAMxB,EAAQD,EAAU0B,cACxB,OAAOD,EAAWE,MAAK,CAACC,EAAGC,IAAM5B,EAAMM,QAAQqB,GAAK3B,EAAMM,QAAQsB,IACtE,CAOO,SAASC,EAAYC,EAAOC,GAC/B,MAAMC,EAAMF,EAAM3E,UAClB,MAAM8E,EAAMF,EAAM5E,UAClB,OAAQ6E,EAAMC,IAAQ,IAAO,KAAO,GACxC,CAOO,SAAS7D,EAAYrB,GACxBA,EAAKmF,SAAS,GAAI,GAAI,GAAI,KAC1B,OAAOnF,CACX,Q"}